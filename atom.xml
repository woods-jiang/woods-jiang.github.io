<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Woods Jiang]]></title>
  <subtitle><![CDATA[Talk less. Think more. Do more than more.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://woodsjiang.com/"/>
  <updated>2015-04-25T03:02:44.535Z</updated>
  <id>http://woodsjiang.com/</id>
  
  <author>
    <name><![CDATA[Woods Jiang]]></name>
    <email><![CDATA[woods.jiang.1@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[leetcode]Best Time to Buy and Sell Stock II]]></title>
    <link href="http://woodsjiang.com/2015/04/25/leetcode-Best-Time-to-Buy-and-Sell-Stock-II/"/>
    <id>http://woodsjiang.com/2015/04/25/leetcode-Best-Time-to-Buy-and-Sell-Stock-II/</id>
    <published>2015-04-25T02:41:22.000Z</published>
    <updated>2015-04-25T03:02:44.535Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h1 id="思路">思路</h1><p>参考上一篇文章<a href="http://woodsjiang.com/2015/04/25/leetcode-Best-Time-to-Buy-and-Sell-Stock/" target="_blank" rel="external">Best Time to Buy and Sell Stock</a>，在上一个题目中，只能完完成一次交易，这里将其拓展了，可以进行任意次交易。</p>
<p>仍然采用<code>minPrice</code>来保存局部的最小值，当<code>prices[i] &gt; prices[i+1]</code>时，说明数组元素开始下降，需要立即更行profit的值</p>
<p>同时更新<code>minPrice</code>的值，注意这里是用<code>prices[i]</code>的值更新<code>minPrice</code>，而不是较小的<code>prices[i+1]</code>来更新，因为要考虑到溢出的问题，在if里面其实就已经判断了，<code>i==prices.size()-1</code>的条件。这里的<code>minPrice</code>更新后，其实是等于前一个单调区间的最大值，不过没关系，到下一次循环的时候立刻就会被更新。</p>
<h1 id="代码">代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minPrice = INT_MAX, profit = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">            &#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(i == prices.size()</span>-1 || prices[i] &gt; prices[i+1])</span><br><span class="line">            </span>&#123;</span><br><span class="line">                profit = profit + prices[i] - minPrice;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1><p>时间复杂度$O(n)$，空间复杂度为$O(1)$</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$.</p>
<p>Design an algori]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://woodsjiang.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode]Best Time to Buy and Sell Stock]]></title>
    <link href="http://woodsjiang.com/2015/04/25/leetcode-Best-Time-to-Buy-and-Sell-Stock/"/>
    <id>http://woodsjiang.com/2015/04/25/leetcode-Best-Time-to-Buy-and-Sell-Stock/</id>
    <published>2015-04-25T02:28:20.000Z</published>
    <updated>2015-04-25T02:39:20.336Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<h1 id="思路">思路</h1><p>采用动态规划的思想，使用minPrice保存已经扫描到的最小值，如果当前价格-minPrice大于profit，即存在更大利益，更新profit的值。整个思路都比较简单</p>
<h1 id="代码">代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minPrice = INT_MAX, profit = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;prices.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">            &#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(prices[i] - minPrice &gt; profit)</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                profit = prices[i] - minPrice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="分析">分析</h1><p>时间复杂度$O(n)$，空间复杂度为$O(1)$</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$.</p>
<p>If you were only]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://woodsjiang.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode]Search For A Range]]></title>
    <link href="http://woodsjiang.com/2015/04/24/leetcode-Search-For-A-Range/"/>
    <id>http://woodsjiang.com/2015/04/24/leetcode-Search-For-A-Range/</id>
    <published>2015-04-24T02:13:50.000Z</published>
    <updated>2015-04-24T02:24:39.069Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log$n$).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p><strong>For example</strong>,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p>
<h1 id="思路">思路</h1><p>采用二分查找的思想，首先，找到最左边的等于target的数，如果没有找到就返回<code>[-1,-1]</code><br>然后再使用二分查找一次，找到最右边的等于target的数<br>两次二分查找时间复杂度均为O(log$n$)，所以总的时间复杂度为O(log$n$)</p>
<p><code>注意</code>体会两个while中的if判断条件的不同</p>
<h1 id="代码">代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> searchRange(<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span>&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;</span> result(&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先找到左边第一个target</span></span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//防止溢出</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start &gt; nums.size()-<span class="number">1</span> || nums[start] != target)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 保存最左边第一个数的下标</span></span><br><span class="line">        result[<span class="number">0</span>] = start;</span><br><span class="line">        </span><br><span class="line">        end = nums.size() -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再找到右边第一个target</span></span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>; <span class="comment">//防止溢出</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target)</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">1</span>] = end;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="分治" scheme="http://woodsjiang.com/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串编辑距离]]></title>
    <link href="http://woodsjiang.com/2015/04/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://woodsjiang.com/2015/04/23/字符串编辑距离/</id>
    <published>2015-04-23T00:13:00.000Z</published>
    <updated>2015-04-23T00:13:49.559Z</updated>
    <content type="html"><![CDATA[<h1 id="编辑距离">编辑距离</h1><p><strong>编辑距离</strong>，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<p>例如将kitten一字转成sitting：</p>
<ol>
<li>sitten （k→s）</li>
<li>sittin （e→i）</li>
<li>sitting （→g）</li>
</ol>
<p>俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。（来源于<a href="http://www.wikiwand.com/zh-cn/%E7%B7%A8%E8%BC%AF%E8%B7%9D%E9%9B%A2" target="_blank" rel="external">维基百科</a> ）</p>
<h1 id="思路">思路</h1><p>采用动态规划求解，下面是状态转移方程<br>if i==0 &amp;&amp; j==0, dp[i][j] = 0;<br>if i==0 &amp;&amp; j&gt;0,  dp[i][j] = j;<br>if i&gt;0  &amp;&amp; j==0, dp[i][j] = i;<br>if i&gt;=1 &amp;&amp; j&gt;=1, dp[i][j] = min(min(dp[i-1][j],dp[i][j-1])+1,dp[i-1][j-1]+same)<br>上面的same满足如下条件<br>if s1[i-1]==s2[j-1], same=0;<br>else same = 1;<br>具体实现就比较简单了。</p>
<h1 id="代码">代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MIN(a,b) (a)&lt;(b)?(a):(b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_LEN = <span class="number">100</span>;     <span class="comment">// 字符串最大长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_dp[MAX_LEN][MAX_LEN];  <span class="comment">// 避免频繁的申请空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Levenshtein</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.size();</span><br><span class="line">    <span class="keyword">int</span> len2 = s2.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)</span><br><span class="line">        g_dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; i++)</span><br><span class="line">        g_dp[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> same = s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">            g_dp[i][j] = MIN(MIN(g_dp[i-<span class="number">1</span>][j], g_dp[i][j-<span class="number">1</span>])+<span class="number">1</span>, g_dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+same);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"else"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Levenshtein(s1, s2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s1.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s2.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; g_dp[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="输出结果">输出结果</h1><p>3<br>0 1 2 3 4<br>1 1 2 3 4<br>2 1 2 3 3<br>3 1 1 2 3<br>4 1 1 2 3<br>5 1 2 2 3</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="编辑距离">编辑距离</h1><p><strong>编辑距离</strong>，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<p>例如]]>
    </summary>
    
      <category term="Algorithm" scheme="http://woodsjiang.com/tags/Algorithm/"/>
    
      <category term="动态规划" scheme="http://woodsjiang.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="Algorithm" scheme="http://woodsjiang.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode]Happy Number]]></title>
    <link href="http://woodsjiang.com/2015/04/22/leetcode-Happy-Number/"/>
    <id>http://woodsjiang.com/2015/04/22/leetcode-Happy-Number/</id>
    <published>2015-04-22T14:10:06.000Z</published>
    <updated>2015-04-22T14:25:14.838Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>$Example:$ 19 is a happy number</p>
<p>$1^2$ + $9^2$ = 82<br>$8^2$ + $2^2$ = 68<br>$6^2$ + $8^2$ = 100<br>$1^2$ + $0^2$ + $0^2$ = 1</p>
<h1 id="思路">思路</h1><p>如果一个数不是Happy Number的话，那么它在做上述的操作过程中，一定会出现循环，即出现一个数，这个数在以前出现过。</p>
<p>所以只需要用一个set来记住以前出现过的结果，当再次出现时，即判定该数不是Happy Number，这里我们使用的是C++11里面的unordered_map。</p>
<pre><code><span class="escape">`另</span>外<span class="escape">`如</span>果不用上面的方法，而控制迭代次数也是可以AC的，比如我试过，只迭代<span class="number">10</span>，如果该数还未等于<span class="number">1</span>，则<span class="keyword">return</span> <span class="literal">false</span>，也可以AC，但是这样子做是有风险的，毕竟可能存在某数需要迭代很多次才能够得到最终的结果。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="stl_container"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;</span> isAppear;</span><br><span class="line">        </span><br><span class="line">        isAppear.insert(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span> != sum)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">                n = n/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isAppear.find(sum)!=isAppear.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">            isAppear.insert(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following pro]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数指针的定义方法]]></title>
    <link href="http://woodsjiang.com/2015/04/22/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/"/>
    <id>http://woodsjiang.com/2015/04/22/函数指针的定义方法/</id>
    <published>2015-04-22T08:28:01.000Z</published>
    <updated>2015-04-22T09:16:04.306Z</updated>
    <content type="html"><![CDATA[<h1 id="函数指针">函数指针</h1><p>函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数。</p>
<p>函数指针有两个用途：调用函数和做函数的参数。</p>
<h1 id="函数指针的定义方法">函数指针的定义方法</h1><p>第一种是普通方法，没有使用typedef</p>
<p>第二种是最常见写法，使用typedef，可以简化写法</p>
<p>第三种是第二种方法的变形，相当于定义一个函数类型，然后使用这个类型后面加上<code>*</code>表示它是一个指针，就相当于是多了一种变量类型，跟<code>int</code>和<code>char</code>定义指针变量类似，注意体会它与第二种方法的不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PFUN)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(FUN)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBack1</span><span class="params">(PFUN pFun)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pFun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBack2</span><span class="params">(FUN *pFun)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    pFun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// （1）函数指针的定义</span></span><br><span class="line">    <span class="keyword">void</span>(*FF)();</span><br><span class="line"></span><br><span class="line">    FF = Print;</span><br><span class="line"></span><br><span class="line">    FF();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （2）最常见的写法</span></span><br><span class="line">    CallBack1(Print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （3）另外一种写法</span></span><br><span class="line">    CallBack2(Print);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出三个“Hello world”</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数指针">函数指针</h1><p>函数指针是指向函数的指针变量。 因而“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量]]>
    </summary>
    
      <category term="C/C++" scheme="http://woodsjiang.com/tags/C-C/"/>
    
      <category term="C/C++" scheme="http://woodsjiang.com/categories/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode]Find Minimum in Rotated Sorted Array]]></title>
    <link href="http://woodsjiang.com/2015/04/20/leetcode-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://woodsjiang.com/2015/04/20/leetcode-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2015-04-20T14:19:41.000Z</published>
    <updated>2015-04-24T02:22:21.776Z</updated>
    <content type="html"><![CDATA[<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h1 id="数组中无重复元素">数组中无重复元素</h1><p>观察旋转数组特点，采用二分查找的思想，把查找时间按复杂度降低到O(log$n$)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[start] &gt;= nums[end])</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(end - start == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[start] &lt; nums[mid])</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(nums[mid] &lt; nums[end])</span></span><br><span class="line">                end </span>= mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="数组中有重复元素">数组中有重复元素</h1><pre><code>Follow up <span class="keyword">for</span> <span class="string">"Find Minimum in Rotated Sorted Array"</span>:
What <span class="keyword">if</span> duplicates are allowed?

Would this affect <span class="keyword">the</span> <span class="command">run</span>-<span class="property">time</span> complexity? How <span class="keyword">and</span> why?
</code></pre><p>当数组中存在重复元素时，比如<code>1 0 1 1 1</code>，上面的方法就会错过最小值0了。<br>如果出现这种极端情况时，就只能挨着一个一个找最小值了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(nums[start] &gt;= nums[end])</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(end - start == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = end;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (start+end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[start]==nums[mid]&amp;&amp;nums[mid]&amp;&amp;nums[end])</span><br><span class="line">                <span class="keyword">return</span> FindMinInOrder(nums);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[start] &lt;= nums[mid])</span><br><span class="line">                start = mid;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(nums[mid] &lt;= nums[end])</span></span><br><span class="line">                end </span>= mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindMinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 ]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="分治" scheme="http://woodsjiang.com/tags/%E5%88%86%E6%B2%BB/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode]Compare Version Numbers]]></title>
    <link href="http://woodsjiang.com/2015/04/14/leetcode-Compare-Version-Numbers/"/>
    <id>http://woodsjiang.com/2015/04/14/leetcode-Compare-Version-Numbers/</id>
    <published>2015-04-14T08:27:11.000Z</published>
    <updated>2015-04-14T08:34:02.672Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br>If <em>version1</em> &gt; <em>version2</em> return 1, if <em>version1</em> &lt; <em>version2</em> return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br>The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br>For instance, <code>2.5</code> is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<pre><code>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37
</code></pre><h1 id="思路">思路</h1><p>以<code>.</code>为间隔，将每个段的字符串转化为整形数字之后再比较。</p>
<h1 id="C++代码">C++代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 != version1.length() || index2 != version2.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (index1 != version1.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (version1[index1] == <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    index1++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum1 = sum1 * <span class="number">10</span> + version1[index1] - <span class="string">'0'</span>;</span><br><span class="line">                index1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (index2 != version2.length())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (version2[index2] == <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    index2++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum2 = sum2 * <span class="number">10</span> + version2[index2] - <span class="string">'0'</span>;</span><br><span class="line">                index2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum1 &gt; sum2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(sum1 &lt; sum2)</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><p>Compare two version numbers <em>version1</em> and <em>version2</em>.<br>If <em>version1</em> &gt; <em>version2</em> re]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode]Number of Islands]]></title>
    <link href="http://woodsjiang.com/2015/04/10/leetcode-NumberOfIslands/"/>
    <id>http://woodsjiang.com/2015/04/10/leetcode-NumberOfIslands/</id>
    <published>2015-04-10T06:58:36.000Z</published>
    <updated>2015-04-24T02:23:15.796Z</updated>
    <content type="html"><![CDATA[<h1 id="原题题目">原题题目</h1><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong><em>Example 1:</em></strong></p>
<pre><code>11110
11010
11000
00000
</code></pre><p>Answer: 1</p>
<p><strong><em>Example 2:</em></strong></p>
<pre><code>11000
11000
00100
00011
</code></pre><p>Answer: 3</p>
<h1 id="思路">思路</h1><p>采用深度优先搜索的方法，搜索值为1的char，找到一个1时，将其上下左右的值都设置为2，这样避免以后再次搜索到他们。</p>
<h1 id="C++代码如下">C++代码如下</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span>&lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        m = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">'1'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                ++result;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i &gt;= m || j&lt;<span class="number">0</span> || j &gt;= n)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Solution obj;</span><br><span class="line"></span><br><span class="line">    <span class="stl_container"><span class="built_in">vector</span>&lt;<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;</span>&gt;</span> grid(<span class="number">4</span>,<span class="stl_container"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">3</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">0</span>][<span class="number">4</span>] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    grid[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">1</span>][<span class="number">3</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">1</span>][<span class="number">4</span>] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    grid[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'1'</span>;</span><br><span class="line">    grid[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">2</span>][<span class="number">3</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">2</span>][<span class="number">4</span>] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    grid[<span class="number">3</span>][<span class="number">0</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">3</span>][<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">3</span>][<span class="number">2</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">3</span>][<span class="number">3</span>] = <span class="string">'0'</span>;</span><br><span class="line">    grid[<span class="number">3</span>][<span class="number">4</span>] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj.numIslands(grid) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用广度优先搜索也可以呢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题题目">原题题目</h1><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="搜索" scheme="http://woodsjiang.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++单例模式]]></title>
    <link href="http://woodsjiang.com/2015/04/09/C++%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://woodsjiang.com/2015/04/09/C++单例模式/</id>
    <published>2015-04-09T14:59:03.000Z</published>
    <updated>2015-04-10T01:51:33.637Z</updated>
    <content type="html"><![CDATA[<h1 id="单例模式定义">单例模式定义</h1><p>单例模式是设计模式的一种，即只能产生一个对象的类</p>
<h1 id="懒汉模式">懒汉模式</h1><p>所谓懒汉模式即第一次调用的时候才产生对象。这需要用锁才能够保证线程安全，但是如果处理大量数据时，性能不好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CSingleton</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> CSingleton* getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL == m_instance)</span><br><span class="line">        &#123;</span><br><span class="line">            Lock();</span><br><span class="line">            <span class="keyword">if</span> (NULL == m_instance)</span><br><span class="line">            &#123;</span><br><span class="line">                m_instance = <span class="keyword">new</span> CSingleton;</span><br><span class="line">            &#125;</span><br><span class="line">            UnLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> CSingleton* m_instance;</span><br><span class="line">    CSingleton()&#123;&#125;</span><br><span class="line">    CSingleton(<span class="keyword">const</span> CSingleton&amp;);</span><br><span class="line">    CSingleton &amp;<span class="keyword">operator</span> =(<span class="keyword">const</span> CSingleton&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::m_instance = NULL;</span><br></pre></td></tr></table></figure>
<p><code>注意</code>，这里的普通构造函数、拷贝构造函数还有重载的操作符“=”都是私有的。而且拷贝构造函数和重载的“=”都不需要实现，这样的好处是即使是在友元类中也无法使用。</p>
<p>上面代码也并不完美，new出来的空间还没有被回收呢，我们都知道，在程序结束时，系统会自动析构所有的全局对象，系统也会自动析构所有类的静态成员变量，利用这个特征，我们在类里面加入一个类CGarbageCollector，在该类中定义一个静态成员变量，在其析构函数中释放单例模式中new出来的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CSingleton</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> CSingleton* getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> CSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CSingleton()&#123;&#125;</span><br><span class="line">    CSingleton(<span class="keyword">const</span> CSingleton&amp;);</span><br><span class="line">    CSingleton &amp;<span class="keyword">operator</span> =(<span class="keyword">const</span> CSingleton&amp;);</span><br><span class="line">    <span class="keyword">static</span> CSingleton* m_pInstance;</span><br><span class="line">    <span class="keyword">class</span> CGarbageCollector</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbageCollector()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (CSingleton::m_pInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> CSingleton::m_pInstance;</span><br><span class="line">                CSingleton::m_pInstance = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbageCollector Garb;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::m_pInstance = NULL;</span><br></pre></td></tr></table></figure>
<p>更加简洁的懒汉模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CSingleton</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> CSingleton&amp; getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> CSingleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CSingleton()&#123;&#125;</span><br><span class="line">    CSingleton(<span class="keyword">const</span> CSingleton&amp;);</span><br><span class="line">    CSingleton&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CSingleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里巧妙的运用了静态变量，而且还不需要考虑销毁的问题，不过要非常<code>注意</code>的是，这里在C++0x及其以后的标准中才是线程安全的。</p>
<h1 id="饿汉模式">饿汉模式</h1><p>为什么叫做饿汉模式呢？这是相对于懒汉模式来说的，因为类的静态成员变量在执行主函数之前就初始化了的，也就是说，这个单例对象在主函数执行前就创建了，想饿汉一样，看见东西先吃了再说，这里就是不管三七二十一，不管用不用得上，先创建一个对象再说。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CSingleton</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> CSingleton* getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> CSingleton* m_pInstance;</span><br><span class="line">    CSingleton()&#123;&#125;</span><br><span class="line">    CSingleton(<span class="keyword">const</span> CSingleton &amp;);</span><br><span class="line">    CSingleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CSingleton &amp;);</span><br><span class="line">    <span class="keyword">class</span> CGarbageCollector</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~CGarbageCollector()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (CSingleton::m_pInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> CSingleton::m_pInstance;</span><br><span class="line">                CSingleton::m_pInstance = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> CGarbageCollector Garb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CSingleton* CSingleton::m_pInstance = <span class="keyword">new</span> CSingleton;</span><br></pre></td></tr></table></figure>
<p>同样，采用了跟上面一样的方法来释放内存。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="单例模式定义">单例模式定义</h1><p>单例模式是设计模式的一种，即只能产生一个对象的类</p>
<h1 id="懒汉模式">懒汉模式</h1><p>所谓懒汉模式即第一次调用的时候才产生对象。这需要用锁才能够保证线程安全，但是如果处理大量数据时，性能不好。</]]>
    </summary>
    
      <category term="C++" scheme="http://woodsjiang.com/tags/C/"/>
    
      <category term="设计模式" scheme="http://woodsjiang.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="C/C++" scheme="http://woodsjiang.com/categories/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[找出词典中所有的变位词]]></title>
    <link href="http://woodsjiang.com/2015/04/09/%E6%89%BE%E5%87%BA%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D/"/>
    <id>http://woodsjiang.com/2015/04/09/找出词典中所有的变位词/</id>
    <published>2015-04-09T11:34:04.000Z</published>
    <updated>2015-04-10T01:53:34.537Z</updated>
    <content type="html"><![CDATA[<h1 id="什么是变位词">什么是变位词</h1><p>两个词语所有的字母个数相同，但是字母顺序不一样的词语，成他们互为对方的变位词</p>
<h1 id="问题描述">问题描述</h1><p>给定一本词典，找出词典中的所有变位词</p>
<h1 id="解决思路">解决思路</h1><p>设置一个map来存储变位词，key是每个单词排列好的数序，value是一个存放string的set，用来存放所有的变位词。</p>
<pre><code>依次扫描每一个单词，并且排序
将排序好的单词作为<span class="variable">key</span>存放在<span class="built_in">map</span>中，而单词本身存放在value的<span class="built_in">set</span>容器中。
遍历输出<span class="built_in">map</span>，得到变位词表
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;fstream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;map&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;set&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">charcomp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> x, <span class="keyword">const</span> <span class="keyword">char</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入文件名字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anagramme</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; filename)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">("output.txt")</span></span>;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    <span class="stl_container"><span class="built_in">map</span> &lt; <span class="built_in">string</span>, <span class="stl_container"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;</span>&gt;</span> wordmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取词典</span></span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> strTmp = word;</span><br><span class="line">        sort(word.begin(), word.end(), charcomp);</span><br><span class="line">        wordmap[word].insert(strTmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输出</span></span><br><span class="line">    <span class="stl_container"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="stl_container"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;</span>&gt;</span>::iterator mapIt = wordmap.begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; mapIt != wordmap.end(); ++mapIt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="stl_container"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;</span>::iterator setIt = (mapIt-&gt;second).begin();</span><br><span class="line">        <span class="keyword">for</span> (; setIt != (mapIt-&gt;second).end(); ++setIt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *setIt &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            ofs &lt;&lt; *setIt &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">        ofs &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.close();</span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    anagramme(<span class="string">"dict.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="什么是变位词">什么是变位词</h1><p>两个词语所有的字母个数相同，但是字母顺序不一样的词语，成他们互为对方的变位词</p>
<h1 id="问题描述">问题描述</h1><p>给定一本词典，找出词典中的所有变位词</p>
<h1 id="解决思路">解决思路]]>
    </summary>
    
      <category term="Algorithm" scheme="http://woodsjiang.com/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://woodsjiang.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[K-fold交叉验证]]></title>
    <link href="http://woodsjiang.com/2015/04/07/K-fold%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    <id>http://woodsjiang.com/2015/04/07/K-fold交叉验证/</id>
    <published>2015-04-07T03:16:27.000Z</published>
    <updated>2015-04-07T08:18:14.716Z</updated>
    <content type="html"><![CDATA[<h1 id="适用情况">适用情况</h1><p>假设你将要训练一组数据，现在有m个模型，由$M_{1…m}$表示，需要选择具体使用哪个模型。那么这时就可以用交叉验证来选择模型了。</p>
<h1 id="具体过程">具体过程</h1><p>一、将数据集分为训练集Train和测试集Test。</p>
<p>二、再将训练集Train分成<code>K</code>份，做交叉验证</p>
<p>   (1) 现在从模型$M_{1}$开始，将数据分成<code>K</code>份（K=10比较常见），将其中的9份作为训练集，剩下的一份作为测试集，得到一个评分；然后依次选取一个不同的测试集，剩下的9份作为训练集，直到10份数据每一分都做过一次测试集为止，这时，我们得到10个评分，将这10个评分取平均值，得到模型M1的评分$f_1$。</p>
<p>   (2) 现在开始对模型$M_2$做评分，跟上面采用一样的验证方法，最终得到评分$f_2$</p>
<p>   (3) m个模型，一共得到了m个评分，最终取效果最好的那个模型$M_i$。</p>
<p>三、使用这个评分最好的模型$M_i$的参数，对所有的训练集Train再训练一次。最终数据就训练好了，然后在最开始划分的测试数据集Test上进行测试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="适用情况">适用情况</h1><p>假设你将要训练一组数据，现在有m个模型，由$M_{1…m}$表示，需要选择具体使用哪个模型。那么这时就可以用交叉验证来选择模型了。</p>
<h1 id="具体过程">具体过程</h1><p>一、将数据集分为训练集Train和测]]>
    </summary>
    
      <category term="Machine Learning" scheme="http://woodsjiang.com/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://woodsjiang.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在matlab中添加livsvm及其使用介绍]]></title>
    <link href="http://woodsjiang.com/2015/04/07/%E5%9C%A8matlab%E4%B8%AD%E6%B7%BB%E5%8A%A0livsvm%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://woodsjiang.com/2015/04/07/在matlab中添加livsvm及其使用介绍/</id>
    <published>2015-04-07T01:12:57.000Z</published>
    <updated>2015-04-07T03:17:32.655Z</updated>
    <content type="html"><![CDATA[<h1 id="安装">安装</h1><p>livsvm3.20+matlab2014a</p>
<p>在网上看到很多方法都是比较老版本的libsvm了，现在新版本是不用编译的，在文件夹中已经编译好了，只需要我们将其添加到matlab对应的文件夹中即可。</p>
<p>首先，<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="external">下载livsvm</a>，我下载的是3.20版本的</p>
<p>然后将其解压到matlab的安装文件夹下面（当然，任意文件夹都可以，主要是你下一步设置路径时，能够找到就行了）。</p>
<p>最后，设置路径，如下图，注意，只需要将libsvm目录下的windows这个目录加入到其路径即可。<br><img src="http://7xifo1.com1.z0.glb.clouddn.com/matlab_libsvm.jpg" alt=""></p>
<h1 id="使用">使用</h1><p>读入livsvm自带的一个数据集<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[heart_scale_label, heart_scale_inst] =libsvmread('heart_scale');</span><br></pre></td></tr></table></figure></p>
<p>注意！这个地方的“heart_scale”文件存在于libsvm目录下，虽然我们刚才将这个文件夹添加到了路径中，但是还是不能直接读取，需要将执行路径切换到该目录下，才能够读取文件。</p>
<p>开始训练<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = svmtrain(heart_scale_label,heart_scale_inst);</span><br></pre></td></tr></table></figure></p>
<p>当然这里默认的是线性svm，如果需要其他的方法可以在函数的后面加上参数。</p>
<p>预测结果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svmpredict(heart_scale_label,heart_scale_inst,model);</span><br><span class="line">Accuracy = <span class="number">86.6667</span>% (<span class="number">234</span>/<span class="number">270</span>) (classification)</span><br></pre></td></tr></table></figure></p>
<p>下面看看svm的高斯核函数在上面例子的威力，训练参数设置如下<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = svmtrain(heart_scale_label,heart_scale_inst, '-s 0 -t 2 -g 2');</span><br></pre></td></tr></table></figure></p>
<p>预测结果<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svmpredict(heart_scale_label, heart_scale_inst, model);</span><br><span class="line">Accuracy = <span class="number">99.2593</span>% (<span class="number">268</span>/<span class="number">270</span>) (classification)</span><br></pre></td></tr></table></figure></p>
<p>当然，这并不是最佳的参数，设置‘-g 3’时，还可以达到99.6296%</p>
<p>下面是一些参数的具体意思<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-s</span> svm_<span class="built_in">type</span> : <span class="built_in">set</span> <span class="built_in">type</span> of SVM (default <span class="number">0</span>)</span><br><span class="line">	<span class="number">0</span> -- C-SVC		(multi-class classification)</span><br><span class="line">	<span class="number">1</span> -- nu-SVC		(multi-class classification)</span><br><span class="line">	<span class="number">2</span> -- one-class SVM	</span><br><span class="line">	<span class="number">3</span> -- epsilon-SVR	(regression)</span><br><span class="line">	<span class="number">4</span> -- nu-SVR		(regression)</span><br><span class="line">-t kernel_<span class="built_in">type</span> : <span class="built_in">set</span> <span class="built_in">type</span> of kernel <span class="keyword">function</span> (default <span class="number">2</span>)</span><br><span class="line">	<span class="number">0</span> -- linear: u<span class="string">'*v</span><br><span class="line">	1 -- polynomial: (gamma*u'</span>*v + coef0)^degree</span><br><span class="line">	<span class="number">2</span> -- radial basis <span class="keyword">function</span>: exp(-gamma*|u-v|^<span class="number">2</span>)</span><br><span class="line">	<span class="number">3</span> -- sigmoid: tanh(gamma*u<span class="string">'*v + coef0)</span><br><span class="line">	4 -- precomputed kernel (kernel values in training_set_file)</span><br><span class="line">-d degree : set degree in kernel function (default 3)</span><br><span class="line">-g gamma : set gamma in kernel function (default 1/num_features)</span><br><span class="line">-r coef0 : set coef0 in kernel function (default 0)</span><br><span class="line">-c cost : set the parameter C of C-SVC, epsilon-SVR, and nu-SVR (default 1)</span><br><span class="line">-n nu : set the parameter nu of nu-SVC, one-class SVM, and nu-SVR (default 0.5)</span><br><span class="line">-p epsilon : set the epsilon in loss function of epsilon-SVR (default 0.1)</span><br><span class="line">-m cachesize : set cache memory size in MB (default 100)</span><br><span class="line">-e epsilon : set tolerance of termination criterion (default 0.001)</span><br><span class="line">-h shrinking : whether to use the shrinking heuristics, 0 or 1 (default 1)</span><br><span class="line">-b probability_estimates : whether to train a SVC or SVR model for probability estimates, 0 or 1 (default 0)</span><br><span class="line">-wi weight : set the parameter C of class i to weight*C, for C-SVC (default 1)</span><br><span class="line">-v n: n-fold cross validation mode</span><br><span class="line">-q : quiet mode (no outputs)</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装">安装</h1><p>livsvm3.20+matlab2014a</p>
<p>在网上看到很多方法都是比较老版本的libsvm了，现在新版本是不用编译的，在文件夹中已经编译好了，只需要我们将其添加到matlab对应的文件夹中即可。</p>
<p>首先，<a]]>
    </summary>
    
      <category term="Machine Learning" scheme="http://woodsjiang.com/tags/Machine-Learning/"/>
    
      <category term="Machine Learning" scheme="http://woodsjiang.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[STL中at访问元素与[]访问元素的区别]]></title>
    <link href="http://woodsjiang.com/2015/04/05/STL%E4%B8%ADat%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E4%B8%8E-%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://woodsjiang.com/2015/04/05/STL中at访问元素与-访问元素的区别/</id>
    <published>2015-04-05T14:38:08.000Z</published>
    <updated>2015-04-20T14:16:45.917Z</updated>
    <content type="html"><![CDATA[<h1 id="首先是我的gcc4-8-2版本中的at方法的实现">首先是我的gcc4.8.2版本中的at方法的实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reference</span><br><span class="line"><span class="title">at</span><span class="params">(size_type __n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	_M_range_check(__n);</span><br><span class="line">	<span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_reference</span><br><span class="line"><span class="title">at</span><span class="params">(size_type __n)</span> <span class="keyword">const</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	_M_range_check(__n);</span><br><span class="line">	<span class="keyword">return</span> (*<span class="keyword">this</span>)[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是其中<code>[]</code>的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reference</span><br><span class="line"><span class="keyword">operator</span>[](size_type __n)</span><br><span class="line">&#123; <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n); &#125;</span><br><span class="line"></span><br><span class="line">const_reference</span><br><span class="line"><span class="keyword">operator</span>[](size_type __n) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_M_impl._M_start + __n); &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面我们可以发现，gcc中的<code>at</code>方法对输入边界值进行了检查<code>_M_range_check(__n);</code>而<code>[]</code>方法却没有，所以，采用<code>[]</code>方法效率更高，但是可能会出现越界访问的危险。<br>不过，如果你是用循环遍历来完成的话，用size来控制输出，就不用检查边界，用<code>[]</code>方法访问效率更高。</p>
<h1 id="VS2013中，对Vector的实现">VS2013中，对Vector的实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_reference <span class="title">at</span><span class="params">(size_type _Pos)</span> <span class="keyword">const</span></span><br><span class="line">	</span>&#123;	<span class="comment">// subscript nonmutable sequence with checking</span></span><br><span class="line">	<span class="keyword">if</span> (size() &lt;= _Pos)</span><br><span class="line">		_Xran();</span><br><span class="line">	<span class="keyword">return</span> (*(<span class="keyword">this</span>-&gt;_Myfirst + _Pos));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(size_type _Pos)</span></span><br><span class="line">	</span>&#123;	<span class="comment">// subscript mutable sequence with checking</span></span><br><span class="line">	<span class="keyword">if</span> (size() &lt;= _Pos)</span><br><span class="line">		_Xran();</span><br><span class="line">	<span class="keyword">return</span> (*(<span class="keyword">this</span>-&gt;_Myfirst + _Pos));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type _Pos) <span class="keyword">const</span></span><br><span class="line">		&#123;	<span class="comment">// subscript nonmutable sequence</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> _ITERATOR_DEBUG_LEVEL == 2</span></span><br><span class="line">	<span class="keyword">if</span> (size() &lt;= _Pos)</span><br><span class="line">		&#123;	<span class="comment">// report error</span></span><br><span class="line">		_DEBUG_ERROR(<span class="string">"vector subscript out of range"</span>);</span><br><span class="line">		_SCL_SECURE_OUT_OF_RANGE;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">elif</span> _ITERATOR_DEBUG_LEVEL == 1</span></span><br><span class="line">		_SCL_SECURE_VALIDATE_RANGE(_Pos &lt; size());</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* _ITERATOR_DEBUG_LEVEL */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (*(<span class="keyword">this</span>-&gt;_Myfirst + _Pos));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>[](size_type _Pos)</span><br><span class="line">		&#123;	<span class="comment">// subscript mutable sequence</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> _ITERATOR_DEBUG_LEVEL == 2</span></span><br><span class="line">		<span class="keyword">if</span> (size() &lt;= _Pos)</span><br><span class="line">			&#123;	<span class="comment">// report error</span></span><br><span class="line">			_DEBUG_ERROR(<span class="string">"vector subscript out of range"</span>);</span><br><span class="line">			_SCL_SECURE_OUT_OF_RANGE;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">elif</span> _ITERATOR_DEBUG_LEVEL == 1</span></span><br><span class="line">		_SCL_SECURE_VALIDATE_RANGE(_Pos &lt; size());</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> /* _ITERATOR_DEBUG_LEVEL */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (*(<span class="keyword">this</span>-&gt;_Myfirst + _Pos));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	__declspec(noreturn) <span class="keyword">void</span> _Xran() <span class="keyword">const</span></span><br><span class="line">		&#123;	<span class="comment">// report an out_of_range error</span></span><br><span class="line">		_Xout_of_range(<span class="string">"invalid vector&lt;T&gt; subscript"</span>);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>微软自家实现的vector中，在<code>[]</code>方法中加入了调试信息，也就是说，生成的debug版本时，<code>at</code>和<code>[]</code>方法效率是一样的，都会判断是否越界，且输出相关信息，但是在release版本中，还是跟标准stl的vector一样，<code>[]</code>方法访问更加高效。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="首先是我的gcc4-8-2版本中的at方法的实现">首先是我的gcc4.8.2版本中的at方法的实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class=]]>
    </summary>
    
      <category term="STL" scheme="http://woodsjiang.com/tags/STL/"/>
    
      <category term="STL" scheme="http://woodsjiang.com/categories/STL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[leetcode][bash]Word Frequency]]></title>
    <link href="http://woodsjiang.com/2015/04/04/leetcode-bash-Word-Frequency/"/>
    <id>http://woodsjiang.com/2015/04/04/leetcode-bash-Word-Frequency/</id>
    <published>2015-04-04T06:51:49.000Z</published>
    <updated>2015-04-11T12:53:08.289Z</updated>
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p>来源：<a href="https://leetcode.com/problems/word-frequency/" target="_blank" rel="external">https://leetcode.com/problems/word-frequency/</a><br>Write a bash script to calculate the frequency of each word in a text file <code>words.txt</code>.</p>
<p>For simplicity sake, you may assume:</p>
<ul>
<li><code>words.txt</code> contains only lowercase characters and space <code>&#39; &#39;</code> characters.</li>
<li>Each word must consist of lowercase characters only.</li>
<li>Words are separated by one or more whitespace characters.</li>
</ul>
<p>For example, assume that <code>words.txt</code> has the following content:</p>
<pre><code><span class="keyword">the</span> <span class="property">day</span> <span class="keyword">is</span> sunny <span class="keyword">the</span> <span class="keyword">the</span>
<span class="keyword">the</span> sunny <span class="keyword">is</span> <span class="keyword">is</span>
</code></pre><p>Your script should output the following, sorted by descending frequency:</p>
<pre><code><span class="keyword">the</span> <span class="number">4</span>
<span class="keyword">is</span> <span class="number">3</span>
sunny <span class="number">2</span>
<span class="property">day</span> <span class="number">1</span>
</code></pre><p><strong>Note:</strong><br>Don’t worry about handling ties, it is guaranteed that each word’s frequency count is unique.</p>
<h1 id="Bash脚本">Bash脚本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat words.txt | tr <span class="operator">-s</span> <span class="string">' '</span> <span class="string">'\n'</span>|sort|uniq -c|sort -rn| awk <span class="string">'&#123;print $2" "$1&#125;'</span></span><br></pre></td></tr></table></figure>
<p>解释：<br>tr -s：使用指定字符串替换出现一次或者连续出现多次的字符串，这里就是将一个或者多个空格换成换行符<br>sort：将单词从小到大排序<br>uniq -c：uniq用来去掉连续出现的单词<br>sort -rn：sort默认是升序排列，-r则表示降序，-n则是按照数值大小排序<br>awk ‘{print$2” “$1}’：则是格式化输出，内容的每一行为<code>“ ”</code>中的内容</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="题目">题目</h1><p>来源：<a href="https://leetcode.com/problems/word-frequency/" target="_blank" rel="external">https://leetcode.com/problem]]>
    </summary>
    
      <category term="leetcode" scheme="http://woodsjiang.com/tags/leetcode/"/>
    
      <category term="leetcode" scheme="http://woodsjiang.com/categories/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://woodsjiang.com/2015/03/31/hello-world/"/>
    <id>http://woodsjiang.com/2015/03/31/hello-world/</id>
    <published>2015-03-31T13:19:30.124Z</published>
    <updated>2015-03-31T13:19:30.124Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>